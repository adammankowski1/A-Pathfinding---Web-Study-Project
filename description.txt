Praktycznie bez ¿adnych problemów mo¿emy wytyczyæ najkrótsz¹ œcie¿ke z punktu A do punktu B na szachownicy, gdy nie ma na niej ¿adnych przeszkód.

Genialnie sprawdza siê tutaj algorytm A*.

Algorytm A* polega na znalezieniu wszystkich mo¿liwych ruchów z danego miejsca, a nastêpnie wybranie miejsca najbli¿szego miejsca docelowego.

Najbli¿sze miejsce docelowe ustala siê licz¹c kilka parametrów, oraz porównuj¹c ich sumê:
- Koszt G - dystans od punktu startowego A, do obecnie przetwarzanego ruchu
- Koszt H - dystans od obecnie przetwarzanego ruchu do punktu docelowego B
- Koszt F - suma obydwu powy¿szych kosztów G + H

W ka¿dej iteracji powinien zostaæ wybrany ruch o najmniejszym koszcie F, lub dowolnego ruchu o najmniejszym koszcie (kwestia optymalizacji).

W ogólnym zamyœle koszt G ma zwiêkszaæ siê wraz z ka¿dym ruchem, oznaczaj¹c oddalanie siê od punktu pocz¹tkowego A, a koszt H zmniejszaæ siê, oznaczaj¹c przybli¿anie siê do punktu koñcowego B.

Po ka¿dym ruchu sprawdzamy, czy znajdujemy siê na punkcie docelowym B, lub w jego bezpoœrednim zasiêgu (w zale¿noœci od wytycznych).

Ustalenie najkrótszej drogi na szachownicy z przeszkodami stanowi pewien problem. Powy¿szy schemat algorytmu nie zadzia³a, gdy¿ najprawdopodobniej algorytm zatrzyma siê w pêtli wybieraj¹c krok który zosta³ ju¿ wykorzystany. Potrzebna jest zmiana stanu algorytmu oraz implementacjê kilku innych parametrów dla ka¿dego ruchu wykorzystanego, i mo¿liwego do wykorzystania.

G³ówny zamys³ algorytmu pozostaje bez zmian, musimy natomiast przechowywaæ informacje o tym które ruchy zosta³y ju¿ wykorzystane, gdy¿ wykorzystanych ruchów nie ma ju¿ sensu ponownie wykorzystywaæ (wchodziæ na nie). Musimy przechowywaæ informacjê z jakiego miejsca na szachownicy przesuneliœmy siê na dane pole, oraz jaki by³ tego koszt (G, H, oraz ich suma - F).
Koszt G dojœcia na ka¿de pole wyliczamy poprzez sumê wszystkich ruchów wykonanych, aby wejœæ na to pole.